#include "..\..\main.h"
#include "..\heConverter.h"

void command_set_position(int index, hm::vec3f const& position) {
	HeD3Instance* instance = heD3LevelGetInstance(heD3Level, index);
	heD3InstanceSetPosition(instance, position);
};

void command_set_jumpheight(float height) {
	 HePhysicsActor* actor = heD3Level->physics.actor;
	 actor->actorInfo.jumpHeight = height;
};

void command_set_exposure(float f) {
	 heD3Level->camera.exposure = f;
};

void command_set_gamma(float g) {
	 heD3Level->camera.gamma = g;
};


void command_teleport(hm::vec3f const& position) {
	 if(heD3Level->physics.actor) {
		  hePhysicsActorSetPosition(heD3Level->physics.actor, position);
	 }

	 heD3Level->camera.position = position;
};

void command_toggle_physics_debug() {
	if(heD3Level->physics.enableDebugDraw)
		hePhysicsLevelDisableDebugDraw(&heD3Level->physics);
	/*else
		hePhysicsLevelEnableDebugDraw(&heD3Level->physics, render_engine);
    */
};

void command_toggle_profiler() {
	 heProfilerToggleDisplay();
};

void command_export_texture(std::string const& in, std::string const& out) {
     heTextureCompress(in, out);
     HE_LOG("Successfully converted texture");
};

void command_export_textures() {
    std::string folder = "res/textures/instances";
    std::vector<HeFileDescriptor> files; 
    heWin32FolderGetFiles(folder, files, true);

    for(auto& all : files) {
        std::string out = "bin" + all.fullPath;
        heTextureCompress(all.fullPath, out);
    }
    
    HE_LOG("Successfully converted textures");
};

void command_export_instances() {
    std::string folder = "res/instances";
    std::vector<HeFileDescriptor> files; 
    heWin32FolderGetFiles(folder, files, true);

    for(auto& all : files) {
        std::string out = "bin" + all.fullPath;
        heBinaryConvertD3InstanceFile(all.fullPath, out);
    }
    
    HE_LOG("Successfully converted instance");
};

void command_export_skybox() {
    HeD3Skybox* skybox = &heD3Level->skybox; 
    heTextureExport(skybox->specular, "binres/textures/skybox/" + skybox->specular->name + ".h3asset");
    heTextureExport(skybox->irradiance, "binres/textures/skybox/" + skybox->irradiance->name + ".h3asset");
    HE_LOG("Successfully exported skybox");
};

void command_print_memory() {
    HE_LOG("=== MEMORY ===");
    uint64_t total = heMemoryTracker[HE_MEMORY_TYPE_TEXTURE] +
        heMemoryTracker[HE_MEMORY_TYPE_VAO] + 
        heMemoryTracker[HE_MEMORY_TYPE_FBO] +
        heMemoryTracker[HE_MEMORY_TYPE_SHADER] + 
        heMemoryTracker[HE_MEMORY_TYPE_CONTEXT];

    HE_LOG("textures = " + he_bytes_to_string(heMemoryTracker[HE_MEMORY_TYPE_TEXTURE]));
    HE_LOG("vaos     = " + he_bytes_to_string(heMemoryTracker[HE_MEMORY_TYPE_VAO]));
    HE_LOG("fbos     = " + he_bytes_to_string(heMemoryTracker[HE_MEMORY_TYPE_FBO]));
    HE_LOG("context  = " + he_bytes_to_string(heMemoryTracker[HE_MEMORY_TYPE_CONTEXT]));
    HE_LOG("shaders  = " + he_bytes_to_string(heMemoryTracker[HE_MEMORY_TYPE_SHADER]));
    HE_LOG("total    = " + he_bytes_to_string(total));
    HE_LOG("total    = " + he_bytes_to_string(heMemoryGetUsage()));
    HE_LOG("=== MEMORY ===");
};

void command_print_textures() {
    HE_LOG("=== TEXTURES ===");
    std::string string;
    for(auto const& all : heAssetPool.texturePool)
        he_to_string(&all.second, string);

    HE_LOG(string);   
    HE_LOG("=== TEXTURES ===");
};

void command_print_instances() {
    HE_LOG("=== INSTANCES ===");
    uint16_t counter = 0;
    for(const auto& all : heD3Level->instances) {
        std::string string;
        he_to_string(&all, string);
        HE_LOG('[' + std::to_string(counter++) + "] = " + string);
    }

    HE_LOG("=== INSTANCES ===");
};

void command_print_instance(std::string const& name) {
    uint16_t counter = 0;
    for(const auto& all : heD3Level->instances) {
        if(all.name == name) {
            std::string string;
            he_to_string(&all, string);
            HE_LOG('[' + std::to_string(counter++) + "] = " + string);
        } else
            counter++;
    }
};